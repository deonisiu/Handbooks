
**<!--//*--> ОСНОВНАЯ ИНФОРМАЦИЯ ВЗЯТА С https://git-scm.com/book/ru/v2 <!--*//-->**

## СПИСОК ОПРЕДЕЛЕНИЙ <!--{-->
***GIT*** - распределённая система управления версиями. (https://ru.wikipedia.org/wiki/Git#cite_note-6)

***Secure Hash Algorithm 1*** (SHA-1) - алгоритм криптографического хеширования. (https://ru.wikipedia.org/wiki/SHA-1)


<!--}-->
---
## ОБЩАЯ ИНФОРМАЦИЯ ПРО GIT <!--{-->
Подход Git’а к хранению данных больше похож на набор снимков миниатюрной файловой системы. 
Каждый раз, когда вы делаете коммит, то есть сохраняете состояние своего проекта в Git’е, система запоминает, как выглядит каждый файл в этот момент, и сохраняет ссылку на этот снимок. 
Для увеличения эффективности, если файлы не были изменены, Git не запоминает эти файлы вновь, а только создаёт ссылку на предыдущую версию идентичного файла, который уже сохранён. Git представляет свои данные как, скажем, поток снимков.   
![Поток снимков в Git](https://git-scm.com/book/en/v2/images/snapshots.png)
Git имеет три основных состояния, в которых могут находиться ваши файлы: зафиксированном (committed), изменённом (modified) и подготовленном (staged). 

***Зафиксированный*** (committed) значит, что файл уже сохранён в вашей локальной базе.  
К ***изменённым*** (modified) относятся файлы, которые поменялись, но ещё не были зафиксированы.  
***Подготовленные*** (staged) файлы — это изменённые файлы, отмеченные для включения в следующий коммит.

Мы подошли к трём основным секциям проекта Git:
1) Git-директория (Git directory)
2) рабочая директория (working directory) 
3) область подготовленных файлов (staging area).
![Секции проекта Git](https://git-scm.com/book/en/v2/images/areas.png)

1. Git-директория — это то место, где Git хранит метаданные и базу объектов вашего проекта. Это самая важная часть Git, и это та часть, которая копируется при клонировании репозитория с другого компьютера.

2. Рабочая директория является снимком версии проекта. Файлы распаковываются из сжатой базы данных в Git-директории и располагаются на диске, для того чтобы их можно было изменять и использовать.

3. Область подготовленных файлов — это файл, располагающийся в вашей Git-директории, в нём содержится информация о том, какие изменения попадут в следующий коммит. Эту область ещё называют "индекс", однако называть её stage-область также общепринято.

Базовый подход в работе с Git выглядит так:  
* Вы изменяете файлы в вашей рабочей директории.
* Вы добавляете файлы в индекс, добавляя тем самым их снимки в область подготовленных файлов.
* Когда вы делаете коммит, используются файлы из индекса как есть, и этот снимок сохраняется в вашу Git директорию.

В состав Git’а входит утилита git config, которая позволяет просматривать и настраивать параметры, контролирующие все аспекты работы Git’а, а также его внешний вид. Эти параметры могут быть сохранены в трёх местах:
  1) Файл /etc/gitconfig содержит значения, общие для всех пользователей системы и для всех их репозиториев. Если при запуске git config указать параметр --system, то параметры будут читаться и сохраняться именно в этот файл.
  2) Файл ~/.gitconfig или ~/.config/git/config хранит настройки конкретного пользователя. Этот файл используется при указании параметра --global.
  3) Файл config в каталоге Git’а (т.е. .git/config) в том репозитории, который вы используете в данный момент, хранит настройки конкретного репозитория.
  Настройки на каждом следующем уровне подменяют настройки из предыдущих уровней, то есть значения в .git/config перекрывают соответствующие значения в /etc/gitconfig.
  
<!--}-->
---
## НАСТРОЙКИ (config, help) <!--{-->
### <!--//?--> Смена текстового редактора
` $ git config --global core.editor <redactor_name>`

### <!--//?--> Имя пользователя
` $ git config --global user.name "John Doe"`  
` $ git config --global user.email johndoe@example.com`

### <!--//?--> Проверка настроек
` $ git config --list`

### <!--//?--> Проверка значения конкретного ключа
` $ git config <parametr>`

### <!--//?--> Есть два способа открыть страницу руководства по любой команде Git:
` $ git help <глагол>`  
` $ git <глагол> --help`  
Например: ` $ git help config`

<!--}-->
---
## БАЗОВЫЕ КОМАНДЫ (init, add, commit, grep, rm, mv) <!--{-->
### <!--//?--> Создание репозитория в существующей директории
` $ git init`  
На этом этапе ваш проект ещё не находится под версионным контролем.

### <!--//?--> Отслеживание(добавить под версионный контроль) новый файл
### <!--//?--> Добавить этот контент в следующий коммит
` $ git add <filename>`  
Пример: ` $ git add README`    
` $ git add`, Это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для индексации изменений, а также для других целей, например для указания файлов с исправленным конфликтом слияния. Вам может быть понятнее, если вы будете думать об этом как "добавить этот контент в следующий коммит".

### <!--//?--> Коммит изменений + комментарий в редакторе $EDITOR
` $ git commit`  

### <!--//?--> Коммит изменений + комментарий в строке команды
` $ git commit -m`  
Пример: ` $ git commit -m "comment here"`

### <!--//?--> Игнорирование индексации
` $git commit -a -m "comment"`    
В таком случае не нужно использовать команду ` $ git add`

### <!--//?--> Поиск в истории коммитов или в рабочем каталоге
` $ git grep -n <line-text>` (где -n показывает номер найденной строки или строк)  
Пример:  
` $ git grep -n client`

### <!--//?--> Удаление файла если он ещё не проиндексирован (файл удаляется полностью)
` $ git rm <filename>`

### <!--//?--> Удаление файла даже если он уже проиндексирован (файл удаляется полностью)
` $ git rm -f <filename>`

### <!--//?--> Перевод файла из индекса в untracked (файл не удаляется)
` $ git rm --cached <filename>`  
В команду git rm можно передавать файлы, каталоги или glob-шаблоны.
Например:  
` $ git rm log/\*.log` (* экранируется черех \ , команда удаляет все файлы расширения .log в папке log/  
` $ git rm \*~` (удаляет все файлы, чьи имена заканчиваются на ~)

### <!--//?--> Переименование файла
` $ git mv <file_from> <file_to>`  
Пример: ` $ git mv README.md README.txt`  
Тоже самое если бы мы написали три команды:  
```
$ mv README.md README.txt  
$ git rm README.md  
$ git add README.txt  
```
Пример2:  
` $ mkdir lib`    
` $ git mv hello.html lib`

<!--}-->
---
## СТАТУС ФАЙЛОВ РЕПОЗИТОРИЯ (status, diff) <!--{-->

### <!--//?--> Определение состояния файлов
` $ git status`

### <!--//?--> Графическая утилита, которая показывает все коммиты
` $ gitk [option]`

### <!--//?--> Сокращенный вывод статуса
` $ git status -s`  
Пример:  
```
$ git status -s  
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
```
ГДЕ: 
'M' - 'modified+',  
' M' - 'modified-',  
'A' - add, '??' - untracked,  
'AM' - add and 'modified-',  
'MM' - 'modified+' and 'modified-'  
'modified+' - модифицирован и проиндексирован(готов к коммиту)  
'modified-' - модифицирован и не проиндексирован(не готов к коммиту)

### <!--//?--> Просмотр неиндексированных изменений (до команды $ git add)
` $ git diff`  
` $ git diff [branch-name]` (просмотр изменений ветки "branch-name")  
` $ git diff [file-name]` (просмотр изменений в файле "file-name")

### <!--//?--> Проверка измененных файлов на лишние ПРОБЕЛЫ
` $ git diff --check`

### <!--//?--> Просмотр индексированных изменений (после команды $ git add)
` $ git diff --cached`

### <!--//?--> Сравнение индексированных изменений с последним коммитом
` $ git diff --staged`

<!--}-->
---
## ИГНОРИРОВАНИЕ ФАЙЛОВ (".gitignore")<!--{-->
Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых.   
К таким файлам обычно относятся автоматически генерируемые файлы (различные логи, результаты сборки программ и т.п.).  
В таком случае, вы можете создать файл .gitignore. с перечислением шаблонов соответствующих таким файлам. Вот пример файла .gitignore:

` $ touch .gitignore` (сначала создаем игнор файл)  
Записываем в него правила игнорирования например: '*.gitignore'  
` $ cat .gitignore` (показывает содержимое файла)  
` *.gitignore`

Первая строка предписывает Git игнорировать любые файлы заканчивающиеся на ``.o`` или ``.a`` - объектные и архивные файлы, которые могут появиться во время сборки кода. Вторая строка предписывает игнорировать все файлы заканчивающиеся на тильду (~), которая используется во многих текстовых редакторах, например Emacs, для обозначения временных файлов. Вы можете также включить каталоги log, tmp или pid; автоматически создаваемую документацию; и т.д. и т.п. Хорошая практика заключается в настройке файла .gitignore до того, как начать серьёзно работать, это защитит вас от случайного добавления в репозиторий файлов, которых вы там видеть не хотите.

К шаблонам в файле .gitignore применяются следующие правила:
1. Пустые строки, а также строки, начинающиеся с #, игнорируются.
2. Можно использовать стандартные glob шаблоны.
3. Можно начать шаблон символом слэша (/) чтобы избежать рекурсии.
4. Можно заканчивать шаблон символом слэша (/) для указания каталога.
5. Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого символа.

Glob-шаблоны представляют собой упрощённые регулярные выражения, используемые командными интерпретаторами. Символ (*) соответствует 0 или более символам; последовательность [abc] — любому символу из указанных в скобках (в данном примере a, b или c); знак вопроса (?) соответствует одному символу; и квадратные скобки, в которые заключены символы, разделённые дефисом ([0-9]), соответствуют любому символу из интервала (в данном случае от 0 до 9). Вы также можете использовать две звёздочки, чтобы указать на вложенные директории: a/**/z соответствует a/z, a/b/z, a/b/c/z, и так далее.

Вот ещё один пример файла .gitignore:
```
# no .a files
*.a
# but do track lib.a, even though youre ignoring .a files above
!lib.a
# only ignore the root TODO file, not subdir/TODO
/TODO
# ignore all files in the build/ directory
build/
# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt
# ignore all .txt files in the doc/ directory
doc/**/*.txt
```
<!--}-->
---
## ПРОСМОТР ИСТОРИИ КОММИТОВ (log, show, reflog) <!--{-->
### <!--//?--> Просмотр истории коммитов (сверху последние)
` $ git log`

### <!--//?--> Подробный просмотр коммита
` $ git show` (последний коммит в текущей ветке)  
` $ git show [branch-name]` (последний коммит в ветке "branch-name")  
` $ git show <hash(4 - 7 numb)>` (по первым 4 - 7 цифрам из хеш суммы)

### <!--//?--> Просмотр истории коммитов  + разница внесенная в каждый коммит
` $ git log -p` **<!--//*--> В MERGE НЕ ПОКАЗЫВАЕТ ИЗМЕНЕНИЯ <!--*//-->**  
` $ git log -p -[number]` (где number количество отображаемых коммитов)

### <!--//?--> Просмотр истории коммитов + краткая разница + количество измененных строк
` $ git log --stat`

### <!--//?--> Просмотр истории журнала ссылок
` $ git reflog`

### <!--//?--> Просмотр истории коммитов в одну строку
` $ git log --pretty=oneline`  
` $ git log --oneline` (сокращенная форма, хеш сумма в 7 символов)

### <!--//?--> Просмотр истории коммитов в определенном формате 
**<!--//*--> ДВОЙНЫЕ КАВЫЧКИ РАБОТАТЬ НЕ БУДУТ "view format" <!--*//-->**  
` $ git log --pretty=format:'view format'`  
Пример: 
```
$ git log --pretty=format:'%h - %an, %ar : %s'
$ 4c0ded5 - Denis Savich, 8 minutes ago : Commit 5: A-style.css
$ e4f22c1 - Denis Savich, 7 hours ago : Commit 4: A - delete.txt
```
Опции для FORMAT: $ git log --pretty=format <!--{-->
*	%H - Хеш коммита
*	%h - Сокращенный хеш коммита
*	%T - Хеш дерева
*	%t - Сокращенный хеш дерева
*	%P - Хеш родителей
*	%p - Сокращенный хеш родителей
*	%an - Имя автора
*	%ae - Электронная почта автора
*	%ad - Дата автора (формат даты можно задать опцией --date=option)
*	%ar - Относительная дата автора
*	%cn - Имя коммитера
*	%ce - Электронная почта коммитера
*	%cd - Дата коммитера
*	%cr - Относительная дата коммитера
*	%s - Содержание
*Автор* – это человек, изначально сделавший работу, а *коммитер* – это человек, который последним применил эту работу. 
<!--}-->

### <!--//?--> Посмотр истории коммитов в виде графа
` $ git log --pretty=format:"%h %s" --graph`  
` $ git log --pretty=oneline --graph`  
Показывает текущую ветку и историю слияний

Основные опции для команды ` $ git log` <!--{-->
*	-p - Показывает патч для каждого коммита.
*	--stat - Показывает статистику измененных файлов для каждого коммита.
*	--shortstat - Отображает только строку с количеством изменений/вставок/удалений для команды --stat.
*	--name-only - Показывает список измененных файлов после информации о коммите.
*	--name-status - Показывает список файлов, которые добавлены/изменены/удалены.
*	--abbrev-commit - Показывает только несколько символов SHA-1 чек-суммы вместо всех 40.
*	--relative-date - Отображает дату в относительном формате (например, "2 weeks ago") вместо стандартного формата даты.
*	--graph - Отображает ASCII граф с ветвлениями и историей слияний.
*	--pretty - Показывает коммиты в альтернативном формате. Возможные варианты опций: oneline, short, full, fuller и format (с помощью последней опции вы можете указать свой формат).
<!--}-->

### <!--//?--> Просмотр истории с ограничением вывода
` $ git log -4` (последние 4 записи)  
` $ git log --since=2.weeks` (за последние 2 недели)  
` $ git log --since="2008-01-15"`  
` $ git log --since="2 years 1 day 3 minutes ago"`

### <!--//?--> Фильтрование истории коммитов
` $ git log --author="Savich"` (фильтр по имени автора)  
` $ git log --grep="Commit 3"` (фильтр по ключевым словам в сообщении коммита)  
` $ git log -S"text key"` (фильтр по ключевым словам внутри файла)

Опции для ограничения вывода команды ` $ git log` <!--{-->
*	-(n) - Показывает только последние n коммитов.
*	--since="text", --after="text" - Показывает только те коммиты, которые были сделаны после указанной даты.
*	--until="text", --before="text" - Показывает только те коммиты, которые были сделаны до указанной даты.
*	--author="text" - Показывает только те коммиты, в которых запись author совпадает с указанной строкой.
*	--committer="text" - Показывает только те коммиты, в которых запись committer совпадает с указанной строкой.
*	--grep="text" - Показывает только коммиты, сообщение которых содержит указанную строку.
*	-S"text" - Показывает только коммиты, в которых изменение в коде повлекло за собой добавление или удаление указанной строки.
<!--}-->

### <!--//?--> Поиск в журнале изменений Git
Если вы хотите найти, когда была добавлена константа ZLIB_BUF_MAX, то вы можете с помощью опции -S попросить Git показывать только те коммиты, в которых была добавлена или удалена эта строка:  
` $ git log -SZLIB_BUF_MAX --oneline`

<!--}-->
---
## ОПЕРАЦИИ ОТМЕНЫ (commit --amend, reset, checkout, revert) <!--{-->
### <!--//?--> Переделать последний коммит
` $ git commit --amend [-m "text"]`  
Пример:  
```
$ git commit -m "text"
$ git add file.txt
$ git commit --amend -m "new text"
```
(добавление file.txt в последний коммит + новый комментарий)

### <!--//?--> Сделать коммит, который удаляет изменения, сохраненные нежелательным коммитом
` $ git revert HEAD` (удаляет коммит на котором указатель HEAD)  
` $ git revert <hash>` (удаляет коммит по <hash> номеру)  
При использовании переход в редактор для редактирования коммит сообщения

### <!--//?--> Удаление коммитов из ветки
` $ git reset --hard [<hash> | <tag>]` (переводит указатель HEAD до коммита [<hash> | <tag>] и удаляет все коммиты после)  
Полностью коммиты сразу не удаляются, пока сборщик мусора их не удалит. Если у удаленных коммитов есть теги к ним можно ещё обратиться какое то время (либо по хеш номеру)

### <!--//?--> Отмена подготовки файла (перенос из индекса в рабочую область)
` $ git reset HEAD <file>`  
**<!--//*--> Добавил алиас "reset HEAD --" = "unstage" <!--*//-->**  

### <!--//?--> Отмена изменений файла и откат к последней его версии в Git
` $ git checkout -- <file>` (ОПАСНАЯ КОМАНДА УДАЛЯЕТ ВСЕ ИЗМЕНЕНИЯ ФАЙЛА)  
Всё что удаляется до КОММИТА восстановить уже невозможно!  
**<!--//*--> Добавил алиас "checkout --" = "back" <!--*//-->**
<!--}-->
---
## УДАЛЕННЫЙ РЕПОЗИТОРИЙ (clone, remote, fetch, pull, push) <!--{-->
### <!--//?--> Клонирование существующего репозитория
` $ git clone <path>`  
Пример: ` $ git clone https://github.com/libgit2/libgit2` (directoryname)  
Автоматический добавляет удаленный репозиторий под именем "origin"

### <!--//?--> Создание чистого репозитория
` $ git clone --bare <old-rep> <new-rep>.git`  
В удаленных репозиториях нет смысла хранить рабочие файлы на диске (как это делается в рабочих копиях), а все что им действительно нужно — это дельты изменений и другие бинарные данные репозитория. Вот это и есть "чистый репозиторий". Как правило, репозитории, оканчивающиеся на «.git» являются чистыми репозиториями.

### <!--//?--> Просмотр списка настроенных удаленных репозиториев
` $ git remote`  
Покажет: origin (если это клонированый репозиторий)

### <!--//?--> Просмотр адресов для чтения и для записи привязанные к репозиторию
` $ git remote -v`  
Покажет:  
```
origin  https://github.com/deonisiu/Front-end_websites.git (fetch)
origin  https://github.com/deonisiu/Front-end_websites.git (push)
```
Если у вас больше одного удаленного репозитория команда выведет их все например:  
```
$ git remote -v
bakkdoor  https://github.com/bakkdoor/grit (fetch)
bakkdoor  https://github.com/bakkdoor/grit (push)
cho45     https://github.com/cho45/grit (fetch)
cho45     https://github.com/cho45/grit (push)
defunkt   https://github.com/defunkt/grit (fetch)
defunkt   https://github.com/defunkt/grit (push)
```

### <!--//?--> Добавление удаленных репозиториев
` $ git remote add [shortname] [url]`  
Пример:  
```
$ git remote  
origin
$ git remote add pb https://github.com/paulboone/ticgit
$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
pb	https://github.com/paulboone/ticgit (fetch)
pb	https://github.com/paulboone/ticgit (push)
```
Теперь вместо указания полного пути вы можете использовать pb. Например, если вы хотите получить изменения, которые есть у Пола, но нету у вас, вы можете выполнить команду ` $ git fetch pb`

### <!--//?--> Получение изменений из удаленного репозитория  (либо синхронизация)
` $ git fetch [remote-name]` (появляется новая ветка проекта [remote-name])  
При повторном использование синхронизирует все изменения на сервере с локальными данными и добавляет новые изменения с сервера если они были.  
Пример:  
` $ git remote add den` https://github.com/deonisiu/for-tests2.git  
` $ git fetch den` (добавляет ссылки на все ветки из проекта den)  
В ветке origin при этом ничего не меняется  
Важно отметить, что команда git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

### <!--//?--> Автоматическое получение и слияние изменений из удаленной ветки
` $ git pull` (извлекает (fetch) данные с сервера, с которого изначально склонирован репозиторий и автоматически пытается слить (merge) их с текущим кодом)

### <!--//?--> Отправка изменений в удаленный репозиторий 
` $ git push [remote-name] [branch-name]`  
Пример: ` $ git push origin master` (срабатывает если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Если команду push кто то уже выполнял то ваш push точно будет отклонен. Вам придется сначала вытянуть (pull) их изменения и объеденить с вашими и только потом будет позволено выполнить push.  
` $ git push origin serverfix:awesomebranchname` - здесь говорится "возьми мой serverfix и сделай его удалённым awesomebranchname."

### <!--//?--> Установить связь между удаленным репозиторием и локальной веткой
` $ git push -u <remote> <branch>`  (где -u команда set-upstream)
Пример: ` $ git push -u origin master`

### <!--//?--> Просмотр удаленного репозитория (больше информации)
` $ git remote show [remote-name]`  
Пример: ` $ git remote show origin`

### <!--//?--> Переименование удаленного репозитория на локальной машине
` $ git remote rename [remote-name] [new-name]`  
Пример:  
```
$ git remote 
origin
den
$ git remote rename den denis
$ git remote
origin
denis
```

### <!--//?--> Удаление удаленного репозитория на локальной машине
` $ git remote rm [remote-name]`  
Пример: 
```
$ git remote rm den
$ git remote
origin 
```

### <!--//?--> Удаление веток на удаленном сервере
` $ git push [remote-name] --delete [delete-server-branch-name]`  
Пример:  
` $ git push origin --delete serverfix` (удалит ветку serverfix на сервере)

<!--}-->
---
## РАБОТА С МЕТКАМИ (tag, show, push) <!--{-->
Git использует два основных типа меток: легковесные и аннотированные.
1) Легковесная метка — это что-то весьма похожее на ветку, которая не меняется — это просто указатель на определённый коммит.
2) Аннотированные метки хранятся в базе данных Git’а как полноценные объекты.   Они имеют контрольную сумму, содержат имя поставившего метку, e-mail и дату, имеют комментарий и могут быть подписаны и проверены с помощью GNU Privacy Guard (GPG).

### <!--//?--> Просмотр меток (перечисляет метки в алфавитном порядке)
` $ git tag`   
` $ git tag -l 'text'` (поиск меток по шаблону в 'text')  
Пример: ` $ git tag -l 'v1.8.5*'` (все теги начинающиеся на 'v1.8.5')

### <!--//?--> Создание легковесной метки для последнего коммита
` $ git tag <tag-name>`  
Пример: ` $ git tag v1.4-lt`

### <!--//?--> Создание аннотированной метки  для последнего коммита
` $ git tag -a <tag-name>` (комментарий пишется в vim)  
` $ git tag -a <tag-name> -m "text"` (комментарий пишется в text)  
Пример: ` $ git tag -a v1.4 -m "my version 1.4"`  
Где -m 'text' сообщение метки, которое будет храниться вместе с меткой.

### <!--//?--> Просмотр коммита по тегу
` $ git show <tag-name>`   
Пример: ` $ git show v1.4-lt` (легкий тег покажет коммит с данным тегом)  
Пример: ` $ git show v1.4` (аннотированный тег покажет коммит с данным тегом + инфу по тегу)

### <!--//?--> Удаление тега
` $ git tag -d <tag-name>`

### <!--//?--> Создание метки любому коммиту (через контрольную сумму часть первых символов)
` $ git tag -a <tag-name> 9fceb0` (первые 6 символов контрольной суммы коммита)  
` $ git tag <tag-name> 9fceb0` (тоже самое только для легкого тега)

По умолчанию команда $ git push не отправляет метки на удаленный сервер.
Необходимо явно отправить метки на общий сервер, после их создания.

### <!--//?--> Отправка метки на удаленный сервер
` $ git push [remote-name] [tag-name]`  
Пример: ` $ git push origin v1.4`

### <!--//?--> Отправка всех меток на удаленный сервер
` $ git push [remote-name] --tags`  
Пример: ` $ git push origin --tags`


<!--}-->
---
## ПСЕВДОНИМЫ (config --global alias) (АЛИАСЫ - aliases) <!--{-->
### <!--//?--> Создание нового алиаса
` $ git config --global alias.<text> <git-command>`  
Пример:  
` $ git config --global alias.co checkout` ($ git co вместо $ git checkout)  
` $ git config --global alias.br branch` ($ git br вместо $ git branch)  
` $ git config --global alias.ci commit` ($ git ci вместо $ git commit)  
` $ git config --global alias.st status` ($ git st вместо $ git status)  
` $ git config --global alias.unstage 'reset HEAD'` ($ git unstage <file> вместо $ git reset HEAD <file>)


<!--}-->
---
## ВЕТВЛЕНИЕ В GIT (checkout, branch, merge, rebase) (killer feature) <!--{-->

### ОСНОВНЫЕ КОМАНДЫ <!--{-->
В Git, HEAD это указатель на локальную ветку, в которой вы находитесь.

### <!--//?--> Посмотреть список всех созданных веток
` $ git branch`

### <!--//?--> Посмотреть список всех созданных веток + УДАЛЕННЫХ ВЕТОК
` $ git branch -a`

### <!--//?--> Посмотреть последний коммит на каждой из веток
` $ git branch -v`

### <!--//?--> Посмотреть список веток которые вы слили в ветку на которой сейчас находитесь
` $ git branch --merged`   
` $ git branch --no-merged` (обратная команда)

### <!--//?--> Создание новой ветки
` $ git branch <branch-name>`  
Пример: ` $ git branch testing`  
В результате создается новый указатель на тот же самый коммит, в котором вы находитесь.

### <!--//?--> Создание локальной ветки, которая отслеживает удаленную ветку
` $ git branch --track <branch-name> <remote-name>`  
Пример: ` $ git branch --track style origin/style`  
Теперь ветка style будет везде отображаться и отражать все из origin/style

### <!--//?--> Удаление ветки
` $ git branch -d <branch-name>` (не удаляется если изменения не слиты)  
` $ git branch -D <branch-name>` (сразу удаляется)

### <!--//?--> Переключение веток
` $ git checkout <branch-name>` (переключиться на ветку <branch-name>)  
` $ git checkout -b <branch-name>` (создать ветку и сразу переключиться на нее)  
Пример: ` $ git checkout testing`  
В результате HEAD переместиться на ветку testing  
**<!--//*-->Переключение веток меняет файлы в рабочем каталоге!<!--*//-->**  
Важно запомнить, что когда вы переключаете ветки в Git, файлы в рабочем каталоге меняются. Если вы переключаетесь на старую ветку, то рабочий каталог будет выглядеть так же, как выглядел на момент последнего коммита в ту ветку.  
**<!--//*--> Untracked файлы отображаются во всех ветках <!--*//-->**

### <!--//?--> Перейти на любой коммит в истории по его хэшу
` $ git checkout <hash>` (переключиться на коммит где <hash> 7 значный номер)  
Пример:	
```
$ git checkout 911e8c9
Note: checking out '911e8c9'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b new_branch_name

HEAD is now at 911e8c9... First Commit
$ cat hello.html
Hello, World
```

### <!--//?--> Перейти на любой коммит в истории по его тегу
` $ git checkout <tag-name>`  
Пример: 
```
$ git checkout v1
Previous HEAD position was 8c32287... Added standard HTML page tags
HEAD is now at fa3c141... Added HTML header
```

### <!--//?--> Просмотр всех веток со всеми коммитами в одну строку в виде графа
` $ git log --oneline --graph --all`  
**<!--//*--> Добавил алиас "log --oneline --graph --all" = "all" <!--*//-->**

### <!--//?--> Слияние веток (слияние указанной ветки в текущую)
` $ git merge <branch-name>` (слияние <branch-name> ветки с текущей)  
Если коммит сливается с тем, до которого можно добраться, двигаясь по истории прямо, Git упрощает слияние, просто перенося указатель метки вперед (так как нет разветвления в работе). Это называется ``fast-forward`` (перемотка). 

### <!--//?--> Удаление веток на удаленном сервере
` $ git push [remote-name] --delete [delete-server-branch-name]`  
Пример:  
` $ git push origin --delete serverfix` (удалит ветку serverfix на сервере)

### <!--//?--> Разрешение конфликта слияния через графический инструмент
` $ git mergetool`  
Далее вы можете ввести $ git commit, чтобы завершить коммит слияния.  
` $ git show` покажет подробный результат коммита 

<!--}-->

### КОНФЛИКТ СЛИЯНИЯ <!--{-->
Если вы изменили одну и ту же часть одного и того же файла по-разному в двух объединяемых ветках, Git не сможет их чисто объединить.  
Git не создал коммит слияния автоматически. Он остановил процесс до тех пор, пока вы не разрешите конфликт.   
Чтобы в любой момент после появления конфликта увидеть, какие файлы не объединены, вы можете запустить ` $ git status`  
Все, где есть неразрешенные конфликты слияния, перечисляется как неслитое. Git добавляет в конфликтующие файлы стандартные пометки разрешения конфликтов, чтобы вы могли вручную открыть их и разрешить конфликты.

*Игнорирование пробельных символов*  
В данном конкретном случае конфликты связаны с пробельными символами.   Мы знаем это, так как это простой пример, но в реальных ситуациях это также легко определить при изучении конфликта, так как каждая строка в нем будет удалена и добавлена снова. По умолчанию Git считает все эти строки измененными и поэтому не может слить файлы.

Стратегии слияния, используемой по умолчанию, можно передать аргументы, и некоторые из них предназначены для соответствующей настройки игнорирования изменений пробельных символов. Если вы видите, что множество конфликтов слияния вызваны пробельными символами, то вы можете прервать слияние и запустить его снова, но на этот раз с опцией -Xignore-all-space или -Xignore-space-change. Первая опция игнорирует изменения в любом количестве существующих пробельных символов, вторая игнорирует вообще все изменения пробельных символов.
<!--}-->

### ВЕТВЛЕНИЯ (ТЕОРИЯ) <!--{-->

### **ВИДЫ ВЕТОК** <!--{-->
**<!--//*--> Долгоживущие ветки <!--*//-->**  
Так как в Git применяется простое трехэтапное слияние, ничто не мешает многократно объединять ветки в течении длительного времени. То есть у вас может быть несколько постоянно открытых веток, применяемых для разных этапов цикла разработки. Содержимое некоторых из них будет регулярно сливаться в другие ветки.  
Многие разработчики, использующие Git, придерживаются именно такого подхода, оставляя полностью стабильный код только в ветке master. При этом существует и параллельная ветка с именем develop или next, служащая для работы и тестирования стабильности. После достижения стабильного результата ее содержимое сливается в ветку master.
Схема: C1-C7 коммиты, Master-Develop-Topic ветки
```
C1 - - - - - - - - - - - - - - - - - - - -MASTER>>
   \
	 C2 < - C3 < - C4 < - C5 - - - - - - -DEVELOP>>
							 \
							   C6 < - C7 -TOPIC>>
```	 
**<!--//*--> Тематические ветки <!--*//-->**  
Тематической (topic branch) называется временная ветка, создаваемая и используемая для работы над конкретной функциональной возможностью или решения сопутствующих задач.  
Пример тематических веток hotfix, error для каждой из них было выполнено несколько коммитов, после чего сразу же после слияния с основной веткой они были удалены.  
Работа разделена по уровням, и все изменения в конкретной ветке относятся к определенной теме, а значит, во время просмотра кода проще понять, что и где было сделано.
<!--}-->

### **УДАЛЕННЫЕ ВЕТКИ** <!--{-->
Когда вы хотите поделиться веткой с окружающими, вам необходимо отправить (push) её на удалённый сервер, на котором у вас есть права на запись.  
Ваши локальные ветки автоматически не синхронизируются с удалёнными серверами — вам нужно явно отправить те ветки, которыми вы хотите поделиться.

Важно отметить, что когда при получении данных у вас появляются новые удалённые ветки, вы не получаете автоматически для них локальных редактируемых копий. Другими словами, в нашем случае вы не получите новую ветку serverfix — только указатель origin/serverfix, который вы не можете менять.

Чтобы слить эти наработки в свою текущую рабочую ветку, выполните $ git merge origin/serverfix. Если вам нужна своя собственная ветка serverfix, над которой вы сможете работать, то вы можете создать её на основе удалённой ветки:  
` $ git checkout -b serverfix origin/serverfix`. Это даст вам локальную ветку, на которой можно работать. Она будет начинаться там, где и origin/serverfix.

<!--}-->

<!--}-->

### ОТСЛЕЖИВАНИЕ ВЕТОК <!--{-->
Получение локальной ветки из удалённой ветки автоматически создаёт то, что называется ***отслеживаемой веткой*** (или иногда ***upstream branch***). ***Отслеживаемые ветки*** — это локальные ветки, которые напрямую связаны с удалённой веткой. Если, находясь на отслеживаемой ветке, вы наберёте git pull, Git уже будет знать, с какого сервера получить все удалённые ссылки и сделает слияние с соответствующей удалённой веткой.

Существует общепринятая операция, которую git предоставляет, для создания новой ветки с привязкой к удаленной ветке:
### <!--//?--> Создание локальной отслеживаемой ветки
` $ git checkout --track [remote-name]`  
Пример: ` $ git checkout --track origin/test` - создает локальную ветку test


Если у вас уже есть локальная ветка и вы хотите настроить ее на удаленную ветку, которую вы только получили, или хотите изменить upstream-ветку, которую вы отслеживаете, вы можете воспользоваться ключами -u или --set-upstream-to с командой ` $ git branch`, чтобы явно установить ее в любое время.  
### <!--//?--> Настройка локальной ветки на отслеживание удаленной
` $ git branch -u [remote-name]`  
` $ git branch --set-upstream-to [remote-name]`  
Пример: ` $ git branch -u origin/serverfix`

Сокращение ***Upstream***  
Если у вас есть установленная отслеживаемая ветка, вы можете ссылаться на нее с помощью @<!--{-->upstream<!--}--> или @<!--{-->u<!--}--> сокращенно. Итак, если вы находитесь на master-ветке, а отслеживается origin/master, вы можете вызвать что-то вроде ` $ git merge @<!--{-->u<!--}-->` вместо ` $ git merge origin/master` если хотите.

Если вы хотите посмотреть какие отслеживаемые ветки у вас установлены, вы можете воспользоваться опцией -vv в команде ` $ git branch`. Отобразится список ваших локальных веток с дополнительной информацией, включая то, какая из веток отслеживается, и если локальная ветка опережает, отстает или равняется относительно основной ветки.  
### <!--//?--> Просмотр установленных отслеживаемых веток с удаленным репозиторием
` $ git branch -vv`

Если вы хотите полностью быть в курсе опережающих и отстающих коммитов, вам необходимо извлечь данные из всех ваших удаленных серверов перед запуском этой команды. Вы можете сделать нечто подобное:   
### <!--//?--> ДВЕ команды: обновить данные всех удаленных репозиториев и показать разницу
` $ git fetch --all; git branch -vv`

При установленной отслеживаемой ветке, можно использовать команду: 
` $ git pull` которая содержит в себе сразу две команды: fetch и merge.   Таким образом после команды pull все изменения(commits) на удаленной ветке сразу же появятся в отслеживаемой локальной ветке.


<!--}-->

### ПЕРЕБАЗИРОВАНИЕ (REBASE) <!--{-->
В GIT есть два способа внести изменения из одной ветки в другую: *слияние* (merge) и *перебазирование* (rebase).

При *слиянии*(merge) обе ветки становятся идентичными, а при *перебазировании*(rebase) в текущую ветку добавляются все новые коммиты ветки **"branch-name"**

С помощью команды * rebase* вы можете взять все изменения, которые были зафиксированы (commited) в одной ветке и применить их к другой ветке. 
В Git это называется *перебазированием* (rebasing).
### <!--//?--> Применить все изменения выбранной ветки к текущей (ПЕРЕБАЗИРОВАНИЕ)
` $ git rebase [branch-name]`  
Пример:   
` $ git checkout experiment`  
` $ git rebase master` (в ветке experiment появляются все коммиты из master)

### <!--//?--> Применить все изменения одной ветки к другой (ПЕРЕБАЗИРОВАНИЕ)
` $ git rebase [main-branch] [added-branch]`  
Пример: ` $ git rebase master server` (добавление всех коммитов из ветки server в ветку master)

Если вы взглянете на историю перебазированной ветки, то увидите, что она выглядит абсолютно линейной: будто все операции были выполнены последовательно, даже если изначально они совершались параллельно.  
Часто вы будете делать так для уверенности, что ваши коммиты могут быть бесконфликтно слиты в удалённую ветку.  
Тогда владельцу проекта не придется делать никакой лишней работы — все решится простой перемоткой (fast-forward) или бесконфликтным слиянием.

Снимок, на который ссылается ваш последний коммит — является ли он последним коммитом после перебазирования или коммитом слияния после слияния — в обоих случаях это один и тот же снимок, отличаются только истории коммитов. Перебазирование(rebase) повторяет изменения из одной ветки поверх другой в порядке, в котором эти изменения были представлены, в то время как слияние(merge) берет две конечные точки и сливает их вместе.

### <!--//?--> Перемещение тематической ветки, ответвлённой от другой тематической ветки
` $ git rebase --onto master server client` 

Где master это основная ветка server первая тематическая ветка, а client вторая тематическая ветка находящаяся внутри ветки server.  
После данной команды произойдет переход в ветку client и эта ветка переместиться из подветки для server в продолжение основной ветки master  
**<!--//*--> ДО: <!--*//-->**  
```
C1 < - C2 < - C5 < - C6(master)
		\
		  < - C3 < - C4 < - C10(server)
			   \
				 < - C8 < - C9(client)
```				 
**<!--//*--> ПОСЛЕ: <!--*//-->**   
```
C1 < - C2 < - C5 < - C6(master) < - C8* < - C9*(client)
		\
		  < - C3 < - C4 < - C10(server)
```
Теперь вы можете выполнить перемотку (fast-forward) для ветки master 
```	
$ git checkout master
$ git merge client
```
И получить результат в виде:  
```
C1 < - C2 < - C5 < - C6 < - C8* < - C9*(master, client)
		\
		  < - C3 < - C4 < - C10(server)
```
Затем мы можем добавить все изменения из ветке server в ветку master  
` $ git rebase master server`

И получить результат в виде:
` C1 <- C2 <- C5 <- C6 <- C8* <- C9*(master, client)<- C3 <- C4 <- C10(server)`

### <!--//?--> ОСНОВНОЙ НЕДОСТАТОК ПЕРЕБАЗИРОВАНИЯ:
***<!--//*--> Не перемещайте коммиты, уже отправленные в публичный репозиторий <!--*//-->***

<!--}-->

<!--}-->
---
## СЕРВЕР GIT Глава 4(ВРЕМЕННО ПРОПУЩЕНА)<!--{-->

<!--}-->
---
## УЧАСТИЕ В ПРОЕКТЕ Глава 5 (Общие советы по использованию GIT)<!--{-->
### <!--//?--> Проверка измененных файлов на лишние ПРОБЕЛЫ
` $ git diff --check` (показывает на каких строках есть лишнии пробелы)

### <!--//?--> Интерактивное индексирование (подробнее в главе 7.2)
` $ git add -f` (дополнительный интерфейс для обработки коммитов, которые содержат слишком большое количество новых изменений и файлов)

### <!--//?--> Исправление истории коммитов (подробно в главе 7.6)
До отправки на удаленный сервер, любой коммит может быть изменен.

### <!--//?--> Комментарий коммита
Первая строка должна быть не более 50 символов и содержать основную мысль данного коммита.  
Дальше идёт блок текста описывающий данный коммит более подробно.

<!--}-->
---
## ГИТХАБ Глава 6 (GitHub)(ВРЕМЕННО ПРОПУЩЕНА) <!--{-->

<!--}-->
---
## ИНСТРУМЕНТЫ Git Глава 7 **<!--//*--> ПОЛЕЗНО <!--*//-->** <!--{-->

###  ***ВЫБОР РЕВИЗИИ*** (reglog, show, log) (способы обращения к коммиту) <!--{-->
В данном разделе описываются различные способы обращения к одному коммиту.

Git достаточно умен, чтобы понять какой коммит имеется ввиду по нескольким первым символам ее хеша, если указанная часть SHA-1 имеет в длину по крайней мере 4 символа и однозначна например ` $ git show 1c2d`

Git может вычислить уникальные сокращения для ваших значений SHA-1. Если вы передадите опцию ` $ git log --abbrev-commit`

Если вы хотите просмотреть последний коммит в ветке: ` $ git show topic1`

Одна из вещей, которую Git выполняет в фоновом режиме, пока вы работаете – это ведение "журнала ссылок" – журнала, в котором за последние несколько месяцев сохраняется то, куда указывали HEAD и ветки.
Вы можете просмотреть свой журнал ссылок, используя команду $ git reflog
### <!--//?--> Просмотр истории журнала ссылок
` $ git reflog`

### <!--//?--> Посмотреть какой была HEAD репозитория
` $ git show HEAD@ {5}` (HEAD репозитория 5 шагов назад)

### <!--//?--> Посмотреть где была ветка master вчера
` $ git show master@ {yesterday}`
Такой способ работает только для данных, которые всё еще содержатся в вашем журнале ссылок, поэтому вы не можете использовать ее для коммитов, которые старше нескольких месяцев.

### <!--//?--> Ссылка на предка
` $ git show HEAD^`  
` $ git show HEAD~`
Еще один популярный способ указать коммит – это использовать ее родословную. Если вы поместите "^" в конце ссылки, Git поймет, что нужно использовать родителя этого коммита.

### ДИАПАЗОНЫ КОММИТОВ <!--{-->
Наиболее часто для указания диапазона коммитов используется синтаксис с двумя точками. Таким образом, вы, по сути, просите Git включить в диапазон коммитов только те, которые достижимы из одной, но не достижимы из другой.

Вы хотите посмотреть что находится в вашей экспериментальной ветке, которая еще не была слита в основную. Вы можете попросить Git отобразить в логе только такие коммиты, используя запись master..experiment – она означает "все коммиты, которые доступны из ветки experiment, но не доступны из ветки master".
### <!--//?--> Посмотреть коммиты доступные из ветки bransh2 но не доступные из ветки branch1
` $ git log [branch1]..[branch2]`  
Пример: ` $ git log master..experiment` (Посмотреть коммиты доступные из ветки experiment но не доступные из ветки master)

Другое частое использование такого синтаксиса – просмотр того, что будет отправлено в удаленный репозиторий: ` $ git log origin/master..HEAD`  
Такая команда покажет вам все коммиты вашей текущей ветки, которые отсутствуют в ветке master удаленного репозитория origin.  
### <!--//?--> Посмотреть коммиты которые будут отправлены в удаленный репозиторий
` $ git log origin/master..HEAD` 

Возможно, вы захотите использовать более двух веток для указания нужной ревизии.
Git позволяет сделать это, используя символ "^" или опцию --not, перед любой ссылкой, доступные коммита из которой вы не хотите видеть. Таким образом, следующие три команды эквивалентны:
### <!--//?--> Посмотреть коммиты которые есть в одних ветках но нет в других ("^", "--not")
` $ git log refA..refB`  
` $ git log ^refA refB`  
` $ git log refB --not refA`

Чтобы увидеть все коммиты, доступные из refA и refB, но не доступные из refC
` $ git log refA refB ^refC`  
` $ git log refA refB --not refC`

Последний основной способ выбора ревизий – это синтаксис с тремя точками, который обозначает все коммиты, доступные хотя бы из одной ссылки, но не из обеих сразу. Если вы хотите узнать какие коммиты есть либо в ветке master, либо в experiment, но не в обеих сразу, вы можете выполнить:
### <!--//?--> Посмотреть все коммиты которые есть хотя бы в одной из веток, но не в обеих сразу
` $ git log master...experiment`  
В таких случаях с командой log часто используют опцию --left-right, которая отображает сторону диапазона, с которой была сделана каждая из коммитов. Это делает данную информацию более полезной:  
` $ git log --left-right master...experiment`

<!--}-->

<!--}-->

###  ***ИНТЕРАКТИВНОЕ ИНДЕКСИРОВАНИЕ*** (add -i, add --interactive) <!--{-->
В этом разделе мы рассмотрим несколько интерактивных команд, которые могут упростить создание коммитов, позволяя включать в них только определенный набор файлов и их частей.  
Эти инструменты очень полезны, если вы изменили множество файлов, а затем решили, что хотите чтобы эти изменения были в нескольких маленьких понятных коммитах, а не в одном большом и запутанном.  
Таким способом вы сможете гарантировать, что ваши коммиты представляют логически разделенные изменения и могут быть легко прорецензированы вашими коллегами.

### <!--//?--> Переход в интерактивный консольный режим
` $ git add -i`  
` $ git add --interactive`  
Пример:
```
$ git add -i
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now>
```
Вы можете видеть, что эта команда показывает вашу область подготовленных изменений. Затем следует раздел со списком команд.  
С их помощью вы можете добавить или исключить файлы из индекса, добавить в индекс части файлов, добавить в индекс неотслеживаемые файлы и просмотреть проиндексированные изменения.

### <!--//?--> Добавление файлов в индекс
Если вы введете 2 или u в поле ввода What now>, скрипт спросит у вас какие файлы вы хотите добавить в индекс:  
` Update>>`

Для добавления в индекс файлов TODO и index.html, вы можете ввести их номера:  
```
Update>> 1,2
           staged     unstaged path
* 1:    unchanged        +0/-1 TODO
* 2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update>>
```

Символ * у каждого из этих файлов означает, что файл выбран для индексирования. Если вы нажмете Enter, не вводя ничего в поле ввода Update>>, Git добавит в индекс всё, чтобы было выбрано ранее:  
```
Update>>
updated 2 paths

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now> 1
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
```

### <!--//?--> Удаленеи файла из индекса
Если вы в этот момент хотите исключить файл TODO из индекса, вы можете использовать опции 3 или r (для выполнения revert):
```
*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now> 3
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert>> 1
           staged     unstaged path
* 1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert>> [enter]
reverted one path
```

### <!--//?--> Посмотреть изменения добавленные в индекс
Для того, чтобы посмотреть изменения, которые вы добавили в индекс, вы можете использовать команду 6 и d (для выполнения diff). Она покажет вам список добавленных в индекс файлов, и вы можете выбрать один из них, для которого вы хотите увидеть добавленные в индекс изменения. Это очень похоже на вывод команды ` $ git diff --cached` :
```
*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now> 6
           staged     unstaged path
  1:        +1/-1      nothing index.html
Review diff>> 1
```

### <!--//?--> Индексирование по частям
В Git существует возможность индексировать не только файлы целиком, но и некоторые их части. Например, если вы сделали в файле simplegit.rb два изменения и хотите добавить в индекс только одно из них, добиться этого в Git очень легко.  
В поле ввода в режиме интерактивного индексирования введите 5 или p (для выполнения patch). Git спросит у вас какие файлы вы хотите добавить в индекс частично; а затем для каждой части выбранных файлов он будет показывать изменения в ней и спрашивать хотите ли вы добавить в индекс эту часть:
```
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index dd5ecc4..57399e0 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -22,7 +22,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log -n 25 #<!--{-->treeish<!--}-->")
+    command("git log -n 30 #<!--{-->treeish<!--}-->")
   end

   def blame(path)
Stage this hunk [y,n,a,d,/,j,J,g,e,?]?
```
В этой точке у вас есть множество вариантов дальнейших действий. Если вы введете ?, Git отобразит, что именно вы можете сделать:
```
Добавить в индекс эту часть [y,n,a,d,/,j,J,g,e,?]? ?
y - добавить в индекс эту часть
n - не добавлять в индекс эту часть
a - добавить в индекс эту и все оставшиеся в этом файле части
d - не добавлять в индекс эту и все оставшиеся в этом файле части
g - перейти к некоторой части файла (g - показывает список частей и затем выполняет переход, g<N> - перейти к части N)
/ - найти часть, соответствующую регулярному выражению
j - отложить принятие решения по этой части, перейти к следующей части, решение по которой не принято
J - отложить принятие решения по этой части, перейти к следующей части
k - отложить принятие решения по этой части, перейти к предыдущей части, решение по которой не принято
K - отложить принятие решения по этой части, перейти к предыдущей части
s - разбить текущую часть на части меньшего размера
e - вручную отредактировать текущую часть
? - отобразить помощь
```
Обычно вы будете вводить y или n, если вы хотите индексировать каждую часть по отдельности, но индексация всех частей в некоторых файлах или откладывание решения по индексацию части также может быть полезным. Если вы добавили в индекс одну часть файла, но не добавили другую, состояние вашей рабочей директории будет подобно приведенному далее:
```
What now> 1
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:        +1/-1      nothing index.html
  3:        +1/-1        +4/-0 lib/simplegit.rb
```
Обратите внимание на состояние файла simplegit.rb. Оно говорит вам, что часть строк файла добавлена в индекс, а часть нет. Таким образом, вы частично проиндексировали этот файл. В данный момент вы можете выйти из интерактивного режима команды ` $ git add` и выполнить ` $ git commit`, чтобы зафиксировать частично проиндексированные файлы.

Также вам не обязательно находиться в интерактивном режиме индексирования файлов для выполнения частичной индексации файлов – вы также можете запустить ее, используя команды ` $ git add -p` или ` $ git add --patch`.

Более того, вы можете использовать работу с отдельными частями файлов для частичного восстановления файлов с помощью команды reset --patch, для переключения частей файлов с помощью команды checkout --patch и для прибережения частей файлов с помощью stash save --patch.
<!--}-->

###  ***ПРИБЕРЕЖЕНИЕ И ОЧИСТКА*** (stash, clean) **<!--//*--> ПОЛЕЗНО <!--*//-->** <!--{-->
### <!--//?--> Прибережение наработок определенной ветки (спрятать все изменения)
` $ git stash` (спрятать изменение в выделенное для этого специальное хранилище)  
Позволяет выйти из ветки не совершая коммит над измененными файлами, при этом сохраняя эти файлы для дальнейшего использования  
**<!--//*--> ВАЖНО! Файлы сохраняются в хранилище до их удаления через drop! <!--*//-->**

### <!--//?--> Спрятать только те изменения, которые не добавлены через add в индекс
` $ git stash --keep-index`

### <!--//?--> Спрятать не только все отслеживаемые файлы, но и неотслеживаемые
` $ git stash -u`  
` $ git stash --include-untracked`

### <!--//?--> Спрятать изменения в интерактивном режиме
` $ stash --path`

### <!--//?--> Просмотр списка спрятанных изменений
```
$ git stash list
stash@<!--{-->0<!--}-->: WIP on master: 049d078 added the index file
stash@<!--{-->1<!--}-->: WIP on master: c264051 Revert "added file_size"
stash@<!--{-->2<!--}-->: WIP on master: 21d80a5 added number to log
```

### <!--//?--> Применить спрятанное изменение
` $ git stash apply` (восстановить последнее спрятанное изменение)  
` $ git stash apply stash@{2}` (применить 2 по счету спрятанное изменение)  
**<!--//*--> ВАЖНО! Спрятанные изменения восстановятся в текущей ветке! <!--*//-->**  
**<!--//*--> ВАЖНО! Спрятанные изменения не удаляются из хранилища при apply <!--*//-->**

При восстановлении спрятанных наработок в вашей рабочей директории могут присутствовать измененные и незафиксированные файлы – Git выдаст конфликты слияния, если не сможет восстановить какие-то наработки.

Спрятанные изменения будут применены к вашим файлам, но файлы, которые вы ранее добавляли в индекс, не будут добавлены туда снова. Для того, чтобы это было сделано, вы должны запустить ` $ git stash apply` с опцией --index  
### <!--//?--> Применить спрятанное изменение с добавлением файлов в индекс
` $ git stash apply --index`

### <!--//?--> Удаление спрятанных изменений из временного хранилища
` $ git stash drop` (удаление последнего спрятанного изменения)  
` $ git stash drop stash@{2}` (удаление спрятанного изменения с номером 2)

### <!--//?--> Применить спрятанное изменение и удалить его из хранилища
` $ git stash pop` (последнее в очереди изменение)  
` $ git stash pop stash@{2}` (изменение в очереди под номером 2)

Если восстановление будет затрагивать файл, который уже был изменен с момента сохранения наработок, то вы получите конфликт слияния и должны будете попытаться разрешить его.

### <!--//?--> Создание новой ветки из спрятанных изменений
` $ git stash branch <branch-name>`

### <!--//?--> Очистка рабочей директории  от untracked файлов(ОСТОРОЖНО полное удаление)
` $ git clean`  
` $ git clean -d -n` (-d говорит об удалении директорий, -n отменяет выполнение команды удаление, но показывает то что будет удалено без -n , -i выполнение команды в интерактивном режиме, -f заставить удалить)

По умолчанию команда git clean будет удалять только неотслеживаемые файлы, которые не добавлены в список игнорируемых.

<!--}-->

###  ***ПОДПИСЬ РЕЗУЛЬТАТОВ РАБОТЫ*** (ВРЕМЕННО ПРОПУЩЕНА) <!--{-->
На случай, если вы берете у кого-то в интернете результаты его работы и хотите проверить, что коммиты действительно получены из доверенного источника, в Git есть несколько способов подписать и проверить исходники, используя GPG.


<!--}-->

###  ***ПОИСК В*** Git (grep, log) **<!--//*--> ПОЛЕЗНО <!--*//-->**<!--{-->
Git предоставляет несколько полезных утилит, с помощью которых легко и просто осуществлять поиск по коду и коммитам.

Git поставляется с командой grep, которая позволяет легко искать в истории коммитов или в рабочем каталоге по строке или регулярному выражению.

### <!--//?--> Поиск в истории коммитов или в рабочем каталоге (ПОИСК ВЕЗДЕ)
` $ git grep -n <search-text>` (где -n показывает номер найденной строки или строк)  
` $ git grep --count <search-text>` (показывает файлы с найденной строкой + количество совпадений в каждом файле)  
` $ git grep -p <search-text>` (если вы хотите увидеть метод или функцию, в котором присутствует совпадение, вы можете указать опцию -p)  
` $ git grep --break --heading` (выводит результаты в более читабельном виде)  
` $ git grep <search-text1> --and <search-text2>` (поиск строк сразу с несколькими совпадениями)

### <!--//?--> Поиск в журнале изменений Git
Если вы хотите найти, когда была добавлена константа ZLIB_BUF_MAX, то вы можете с помощью опции -S попросить Git показывать только те коммиты, в которых была добавлена или удалена эта строка:  
` $ git log -SZLIB_BUF_MAX --oneline`

### <!--//?--> Поиск по журналу изменений строки (Не разобрался как работает)
Чтобы ей воспользоваться нужно команде ` $ git log` передать опцию -L, в результате вам будет показана история изменения функции или строки кода в вашей кодовой базе.
Например, если мы хотим увидеть все изменения, произошедшие с функцией git_deflate_bound в файле zlib.c, мы можем выполнить  
` $ git log -L :git_deflate_bound:zlib`  
Эта команда постарается определить границы функции, выполнит поиск по истории и покажет все изменения, которые были сделаны с функцией, в виде набора патчей в обратном порядке до момента создания функции.

<!--}-->

###  ***ИСПРАВЛЕНИЕ ИСТОРИИ КОММИТОВ*** (commit --amend, rebase)**<!--//*--> ПОЛЕЗНО <!--*//-->**<!--{-->
### <!--//?--> (ЕСЛИ ИНДЕКС ПУСТ) Изменение сообщения последнего коммита 
` $ git commit --amend` (откроет редактор для изменения сообщения)

Если вы создали коммит и затем хотите изменить зафиксированный снимок, добавив или изменив файлы (возможно, вы забыли добавить вновь созданный файл, когда совершали изначальную коммит), то процесс выглядит в основном так же. Вы добавляете в индекс необходимые изменения, редактируя файл и выполняя для него ` $ git add` или ` $ git rm` для отслеживаемого файла, а последующая команда ` $ git commit --amend` берет вашу текущую область подготовленных изменений и делает ее снимок для нового коммита.
### <!--//?--> (ЕСЛИ В ИНДЕКС ДОБАВЛЕНЫ ФАЙЛЫ ЧЕРЕЗ add)Изменение последнего коммита
` $ git commit --amend` (откроет редактор для сообщения, а затем заменит старый коммит на новый, с новыми изменениями из индекса)

Вы должны быть осторожными, используя этот прием, так как при этом изменяется SHA-1 коммита. Поэтому как и с операцией rebase – не изменяйте ваш последний коммит, если вы уже отправили ее в общий репозиторий.

* Изменение сообщений нескольких коммитов <!--{-->
В Git отсутствуют инструменты для изменения истории, но вы можете использовать команду rebase. С помощью интерактивного режима команды rebase, вы можете останавливаться после каждого нужного вам коммита и изменять сообщения, добавлять файлы или делать что-то другое, что вам нужно. Вы можете запустить rebase в интерактивном режиме, добавив опцию -i к ` $ git rebase`.

Например, если вы хотите изменить сообщения последних трех коммитов, или сообщение какой-то одному коммиту этой группы, то передайте как аргумент команде ` $ git rebase -i` родителя последнего коммита, который вы хотите изменить – HEAD~2^ или HEAD~3. Может быть, проще будет запомнить ~3, так как вы хотите изменить последние три коммита; но не забывайте, что вы, в действительности, указываете четвертый коммит с конца – родителя последнего коммита, который вы хотите изменить:

` $ git rebase -i HEAD~3`  
Напомним, что это команда перебазирования – каждый коммит, входящая в диапазон HEAD~3..HEAD, будет изменена вне зависимости от того, изменили вы сообщение или нет. Не включайте в такой диапазон коммит, которая уже была отправлена на центральный сервер – сделав это, вы можете запутать других разработчиков, предоставив вторую версию одних и тех же изменений.

Выполнение этой команды отобразит в вашем текстовом редакторе список коммитов, в нашем случае, например, следующее:
```
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
.....
```
Вам необходимо изменить скрипт так, чтобы он остановился на коммите, который вы хотите изменить. Для этого измените слово ‘pick’ на слово ‘edit’ напротив каждой из коммитов, после которых скрипт должен остановиться. Например, для изменения сообщения только третьей коммита, измените файл следующим образом:
```
edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
.....
```
<!--}-->
* Переупорядочивание коммитов <!--{-->
Вы также можете использовать интерактивное перебазирование для переупорядочивания или полного удаления коммитов. Если вы хотите удалить коммит “added cat-file” и изменить порядок, в котором были внесены две оставшиеся, то вы можете изменить скрипт перебазирования с такого:
```
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
```
на такой:
```
pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit
```
Когда вы сохраните скрипт и выйдете из редактора, Git переместит вашу ветку на родителя этих коммитов, применит 310154e, затем f7f3f6d и после этого остановится. Вы, фактически, изменили порядок этих коммитов и полностью удалили коммит “added cat-file”.
<!--}-->
* Объединение коммитов <!--{-->
С помощью интерактивного режима команды rebase также можно объединить несколько коммитов в одну. Git добавляет полезные инструкции в сообщение скрипта перебазирования:
```
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commits log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
```
Если вместо “pick” или “edit” вы укажете “squash”, Git применит изменения из текущей и предыдущей коммитов и предложит вам объединить вместе сообщения коммитов. Таким образом, если вы хотите из этих трех коммитов сделать одну, вы должны изменить скрипт следующим образом:
```
pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file
```
Когда вы сохраните скрипт и выйдете из редактора, Git применит изменения всех трех коммитов и затем вернет вас обратно в редактор, чтобы вы могли объединить сообщения коммитов.
После сохранения сообщения, вы получите один коммит, содержащую изменения всех трех коммитов, существовавших ранее.
<!--}-->
* Разбиение коммита <!--{-->
Разбиение коммита отменяет ее и позволяет затем по частям индексировать и фиксировать изменения, создавая таким образом столько коммитов, сколько вам нужно. Например, предположим, что вы хотите разбить средний коммит на три. Вместо одного коммита “updated README formatting and added blame” вы хотите получить два разных: первый – “updated README formatting”, и второй – “added blame”. Вы можете добиться этого, изменив в скрипте rebase -i инструкцию для разбиваемой коммита на “edit”:
```
pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
```
Затем, когда скрипт вернет вас в командную строку, вам нужно будет отменить индексацию изменений этого коммита, и создать несколько коммитов на основе этих изменений. Когда вы сохраните скрипт и выйдете из редактора, Git переместится на родителя первой коммита в вашем списке, применит первую коммит (f7f3f6d), применит вторую (310154e), и вернет вас в консоль. Здесь вы можете отменить коммит с помощью команды git reset HEAD^, которая, фактически, отменит этот коммит и удалит из индекса измененные файлы. Теперь вы можете добавлять в индекс и фиксировать файлы, пока не создадите требуемые коммита, а после этого выполнить команду git rebase --continue:
```
$ git reset HEAD^
$ git add README
$ git commit -m 'updated README formatting'
$ git add lib/simplegit.rb
$ git commit -m 'added blame'
$ git rebase --continue
```
Git применит последний коммит (a5f4a0d) из скрипта, и ваша история примет следующий вид:
```
$ git log -4 --pretty=format:"%h %s"
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit
```
И снова, при этом изменились SHA-1 хеши всех коммитов в вашем списке, поэтому убедитесь, что ни один коммит из этого списка ранее не был отправлен в общий репозиторий.
<!--}-->
* Продвинутый инструмент: filter-branch (ВРЕМЕННО ПРОПУЩЕННО) <!--{-->

<!--}-->

<!--}-->

###  ***КОМАНДА RESET*** (HEAD, Индекс, Рабочий каталог) <!--{-->
* Три дерева <!--{-->  
Разобраться с командами reset и checkout будет проще, если считать, что Git управляет содержимым трех различных деревьев. Здесь под "деревом" мы понимаем 'набор файлов', а не специальную структуру данных.
В своих обычных операциях Git управляет тремя деревьями:  
```
    -Дерево					--Назначение
    1 -HEAD					Снимок последнего коммита, родитель следующего
    2 -Индекс				Снимок следующего намеченного коммита
    3 -РабочийКаталог		Песочница
```
* HEAD <!--{-->
HEAD – это указатель на текущую ветку, которая, в свою очередь, является указателем на последний коммит, сделанный в этой ветке. Это значит, что HEAD будет родителем следующего созданного коммита. Как правило, самое простое считать HEAD снимком вашего последнего коммита.

На самом деле, довольно легко увидеть, что представляет из себя этот снимок. Ниже приведен пример получения содержимого каталога и контрольных сумм для каждого файла в HEAD:
```
$ git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

$ git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib
```
Команды cat-file и ls-tree являются “служебными” (plumbing) командами, которые используются внутри системы и не требуются при ежедневной работе, но они помогают нам разобраться, что же происходит на самом деле.
<!--}-->
* Индекс <!--{-->
Индекс – это ваш следующий намеченный коммит. Мы также упоминали это понятие как “область подготовленных изменений” Git – то, что Git просматривает, когда вы выполняете ` $ git commit`.

Git заполняет индекс списком изначального содержимого всех файлов, выгруженных в последний раз в ваш рабочий каталог. Затем вы заменяете некоторые из таких файлов их новыми версиями и команда ` $ git commit` преобразует изменения в дерево для нового коммита.
```
$ git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README
100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb
```
Повторим, здесь мы используем служебную команду ls-files, которая показывает вам, как выглядит сейчас ваш индекс.

Технически, индекс не является древовидной структурой, на самом деле, он реализован как сжатый список (flattened manifest) – но для наших целей такого представления будет достаточно.
<!--}-->
* РабочийКаталог <!--{-->
Наконец, у вас есть рабочий каталог. Два других дерева сохраняют свое содержимое эффективным, но неудобным способом внутри каталога .git. Рабочий Каталог распаковывает их в настоящие файлы, что упрощает для вас их редактирование. Считайте Рабочий Каталог песочницей, где вы можете опробовать изменения перед их коммитом в индекс (область подготовленных изменений) и затем в историю.
```
$ tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files
```
<!--}-->


<!--}-->
* Технологический процесс <!--{-->
Основное предназначение Git – это сохранение снимков последовательно улучшающихся состояний вашего проекта, путем управления этими тремя деревьями.

Когда вы переключаетесь (checkout) на ветку, HEAD начинает также указывать на новую ветку, ваш Индекс замещается снимком коммита этой ветки, и затем содержимое Индекса копируется в ваш Рабочий Каталог.

### <!--//?--> Назначение и суть команды RESET
Команда reset может работать тремя основными способами
* Шаг 1: Перемещение HEAD (--soft) <!--{-->
Первое, что сделает reset – переместит то, на что указывает HEAD. Обратите внимание, изменяется не сам HEAD (что происходит при выполнении команды checkout); reset перемещает ветку, на которую указывает HEAD. Таким образом, если HEAD указывает на ветку master (то есть вы сейчас работаете с веткой master), выполнение команды ` $ git reset 9e5e6a4` сделает так, что master будет указывать на '9e5e6a4'. Фактически была отменена последняя команда ` $ git commit`.   
Когда вы выполняете ` $ git commit`, Git создает новый коммит и перемещает на него ветку, на которую указывает HEAD. Если вы выполняете reset на HEAD~ (родителя HEAD), то вы перемещаете ветку туда, где она была раньше, не изменяя при этом ни Индекс, ни Рабочий Каталог. Вы можете обновить Индекс и снова выполнить ` $ git commit`, таким образом добиваясь того же, что делает команда ` $ git commit --amend`.  
**<!--//*-->При вызове reset --soft на шаге №1 выполнение команды остановится. <!--*//-->**  
<!--}-->
* Шаг 2: Обновление Индекса (используется по умолчанию или --mixed) <!--{-->
Заметьте, если сейчас вы выполните ` $ git status`, то увидите отмеченные зеленым цветом изменения между Индексом и новым HEAD.

Следующим, что сделает reset, будет обновление Индекса содержимым того снимка, на который указывает HEAD. Отменен не только последний commit, но также и добавление в индекс всех файлов..

**<!--//*-->При вызове reset --mixed на шаге №2 выполнение команды остановится. <!--*//-->**  
Такое поведение также используется по умолчанию, поэтому если вы не указали совсем никаких опций (в нашем случае ` $ git reset HEAD~`), выполнение команды также остановится на этом шаге.  
<!--}-->
* Шаг 3: Обновление Рабочего Каталога (--hard) <!--{-->
Третье, что сделает reset – это приведение вашего Рабочего Каталога к тому же виду, что и Индекс. Если вы используете опцию --hard, то выполнение команды будет продолжено до этого шага.
В итоге на данном этапе вы отменили ваш последний коммит, результаты выполнения команд ` $ git add` и ` $ git commit`, а также все изменения, которые вы сделали в рабочем каталоге.
Важно отметить, что только указание этого флага (--hard) делает команду reset опасной, это один из немногих случаев, когда Git действительно удаляет данные.
Все остальные вызовы reset легко отменить. 
Если вы коммитили последнюю версию файлов до команды reset --hard внутри базы данных Git то вы можете вернуть ее, просматривая наш reflog, но если вы не коммитили эту версию, Git перезапишет файлы и их уже нельзя будет восстановить.
<!--}-->
* Резюме <!--{-->
Команда reset в заранее определенном порядке перезаписывает три дерева Git, останавливаясь тогда, когда вы ей скажете:

Перемещает ветку, на которую указывает HEAD (останавливается на этом, если указана опция --soft)

Делает Индекс таким же как и HEAD (останавливается на этом, если не указана опция --hard)

Делает Рабочий Каталог таким же как и Индекс.
<!--}-->
* Reset с указанием пути <!--{-->
Основной форме команды reset (без опций --soft и --hard) вы также можете передавать путь, с которым она будет оперировать. В этом случае, reset пропустит первый шаг, а на остальных будет работать только с указанным файлом или набором файлов.

Итак, предположим вы выполнили команду ` $ git reset file.txt`. Эта форма записи (так как вы не указали ни SHA-1 коммита, ни ветку, ни опций --soft или --hard) является сокращением для ` $ git reset --mixed HEAD file.txt`, которая:

Перемещает ветку, на которую указывает HEAD (будет пропущено)
Делает Индекс таким же как и HEAD (остановится здесь)
То есть, фактически, она копирует файл file.txt из HEAD в Индекс.

Это создает эффект отмены индексации файла. Если вы посмотрите на диаграммы этой команды и команды ` $ git add`, то увидите, что их действия прямо противоположные.

Мы легко можем заставить Git 'брать данные не из HEAD', указав коммит, из которого нужно взять версию этого файла. Для этого мы должны выполнить следующее ` $ git reset eb43bf file.txt`.

Заметим, что как и команде ` $ git add`, ` $ git reset` можно указывать опцию --patch для отмены индексации части содержимого. Таким способом вы можете избирательно отменять индексацию или откатывать изменения.
<!--}-->

<!--}-->

<!--}-->

###  ***ПРОДВИНУТОЕ СЛИЯНИЕ*** (Пробельные символы) (ВРЕМЕННО ПРОПУЩЕНА) <!--{-->
* Игнорирование пробельных символов <!--{-->
В данном конкретном случае конфликты связаны с пробельными символами. Мы знаем это, так как это простой пример, но в реальных ситуациях это также легко определить при изучении конфликта, так как каждая строка в нем будет удалена и добавлена снова. По умолчанию Git считает все эти строки измененными и поэтому не может слить файлы.

Стратегии слияния, используемой по умолчанию, можно передать аргументы, и некоторые из них предназначены для соответствующей настройки игнорирования изменений пробельных символов. Если вы видите, что множество конфликтов слияния вызваны пробельными символами, то вы можете прервать слияние и запустить его снова, но на этот раз с опцией -Xignore-all-space или -Xignore-space-change. Первая опция игнорирует изменения в любом количестве существующих пробельных символов, вторая игнорирует вообще все изменения пробельных символов.
<!--}-->

<!--}-->

###  ***КОМАНДА Rerere*** (ВРЕМЕННО ПРОПУЩЕНА) <!--{-->
Функциональность git rerere – частично скрытый компонент Git. Ее имя является сокращением для “reuse recorded resolution” ("повторное использование сохраненных разрешений конфликтов"). Как следует из имени, эта функциональность позволяет попросить Git запомнить то, как вы разрешили некоторую часть конфликта, так что в случае возникновения такого же конфликта, Git сможет его разрешить автоматически.
<!--}-->

###  ***ОБНАРУЖЕНИЕ ОШИБОК С ПОМОЩЬЮ Git*** (blame, bisect) **<!--//*--> ПОЛЕЗНО <!--*//-->** <!--{-->
* Аннотация файла <!--{-->
### <!--//?--> Посмотреть аннотацию определенного файла
` $ git blame <file-name>` (показывает аннотацию всех строк файла)  
` $ git blame -L 12, 22 simple.txt` (показывает строки с 12 по 22)

<!--}-->
* Бинарный поиск <!--{-->
### <!--//?--> Бинарный поиск по истории коммитов (используются сразу 3 команды)
` $ git bisect start` (запуск бинарного поиска)  
` $ git bisect bad` (команда говорит что текущий коммит сломан)  
` $ git bisect good` [good-commit] (указываем на коммит который работал как надо)
Пример:
``` 
$ git bisect start 
$ git bisect bad 
$ git bisect good v1.0
```
Допустим Git выяснил, что произошло около 12 коммитов между коммитом, который вы отметили как последний хороший коммит (v1.0), и текущим плохим коммитом, и выгрузил вам один из середины. В этот момент вы можете запустить ваши тесты, чтобы проверить присутствует ли проблема в этом коммите. Если это так, значит она была внесена до выгруженного промежуточного коммита, если нет, значит проблема была внесена после этого коммита. Пусть в данном коммите проблема не проявляется, вы сообщаете об этом Git с помощью:  
` $ git bisect good`  
Теперь вы оказались на другом коммите, расположенном посредине между только что протестированным и плохим коммитами. Вы снова выполняете ваши тесты, обнаруживаете, что текущий коммит сломан, и сообщаете об этом Git с помощью команды   
` $ git bisect bad`  
Теперь Git имеет всю необходимую информацию для определения того, где была внесена ошибка. Он сообщает вам SHA-1 первого плохого коммита и отображает некоторую информацию о коммите и файлах, которые были изменены в этом коммите, так, чтобы вы смогли разобраться что же случилось, что могло привнести эту ошибку
### <!--//?--> Возврат в исходное состояние после бинарного поиска
` $ git bisect reset`  
Когда вы закончили бинарный поиск, нужно выполнить ` $ git bisect reset` для того, чтобы вернуть HEAD туда, где он был до начала поиска.
<!--}-->

<!--}-->

###  ***ПОДМОДУЛИ*** (ВРЕМЕННО ПРОПУЩЕНА) <!--{-->
Подмодули позволяют вам сохранить один Git-репозиторий, как поддиректорию другого Git-репозитория. Это дает вам возможность склонировать в ваш проект другой репозиторий, но коммиты при этом хранить отдельно.


<!--}-->

<!--}-->