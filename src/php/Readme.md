# PHP

## Полезные ссылки

* [Установка PHP 7.1 в Windows. Командная строка](http://iantonov.me/page/ustanovka-php-71-v-windows-komandnaja-stroka)
* [Установка PHP 7 в картинках и с подробным описанием](https://sebweo.com/ru/ustanovka-php-7-v-kartinkah-i-s-podrobnym-opisaniem/)
* [PhpStorm – как подключить интерпретатор PHP и отладчик Xdebug](http://bogdanov-blog.ru/phpstorm-kak-podklyuchit-interpretator-php-i-otladchik-xdebug/)

---
## Магические методы

### Краткий список
```php
__construct()   -> Конструктор - инициализирует свойства объекта
__destruct()    -> Деструктор - закрывает файлы, разрывает соединения и т.п.
__call()        -> Запускается при вызове недоступных методов в контексте объект
__callStatic()  -> Запускается при вызове недоступных методов в статическом контексте
__get()         -> при записи данных в недоступные или несуществующие свойства
__set()         -> при чтении данных из недоступных или несуществующих свойств
__isset()       -> isset() или empty() на недоступных или несуществующих свойствах
__unset()       -> при вызове unset() на недоступном или несуществующем свойстве
__sleep()       -> когда объект подвергается сериализации при помощи функции serialize()
__wakeup()      -> при восстановлении объекта при помощи функции unserialize()
__toString()    -> при неявном преобразовании ссылки на объект в строку
__invoke()      -> вызывается, когда скрипт пытается выполнить объект как функцию
__set_state()   -> вызывается для тех классов, которые экспортируются функцией var_export()
__clone()       -> если определен, вызывается после завершения клонирования
__debugInfo()   -> вызывается функцией var_dump(), для вывода списка свойств объекта
```

# PHP ООП

## Основы

### Создание класса
```php
class ClassName {
  ...
}
```

### Создание объекта класса
```php
$object1 = new ClassName;     
$object2 = new ClassName();
```

### Доступ к свойствам и методам объекта
```php
$object->param1 = 5;
$object->param2 = "Hello";

$param = $object->getName();
$object->print("Hi");
```

### Константы в классах
```php
class ClassName {
  const NAME = "cls";
  const COUNT = 0;

  function test() {
    //echo $this->NAME;     // Ошибка
    echo self::NAME;        // Верно
    echo ClassName::COUNT;  // Верно
  }
}
```

### Обращение к внутреннему содержимому
* Класса(static) -> ***self*** 
  * `self::method()` - внутри
  * `className::method()` - снаружи
* Объекта -> ***$this*** 
  * `$this->method()` - внутри
  * `$objectName->method()` - снаружи
* Константы -> ***const***
  * `self::constName` - внутри
  * `className::constName` - снаружи

### Неявное объявление свойств
* Не вызывает ошибку даже, если свойство $property в классе не объявлено:
```php
$this->property = 101;  // верно
$obj->property = 101;   // верно

$key = "test";
$obj->$key = 101; // верно создание свойства с именем test

File_Logger::$pass = "ZION10I"; // Fatal error - статические переменные нельзя так создать
```

### Клонирование объектов (clone)
* Копирует данные объекта побитно.
* После операции ***clone*** если переопределен вызывается метод `__clone()`
* Но если объявить метод `__clone()` закрытым (private) клонирование будет запрещено
```php
$x = new ClassName();
$y = clone $x;        // создание КОПИИ объекта $x
```

### Сериализация объектов
* Сериализация имеет ***каскадный*** характер
* Функции ***serialize()*** и ***unserialize()*** - работают с массивами и объектами
  * ***serialize()*** - упаковывает объект в строку
    * Метод `__sleep()` возвращает список имен свойств, подлежащих сериализации
    * Вызывается перед упаковкой объекта
    * Модификатор `public, protected, private` - при сериализации не имеет, значения
    * Все свойства не указанные в списке `__sleep()` игнорируются при упаковке
  * ***unserialize()*** - распаковка из строки в объект
    * Метод `__wakeup()` вызывается ***после распаковки***
* Если в свойстве объекта хранится другой объект
  * Будут вызваны методы `__sleep()` и `__wakeup()` внутреннего объекта
  * Даже если дочерние объекты хранятся в свойстве-массиве 

* Пример метода `__sleep()`
```php
public function __sleep() {
  return ['id', 'name', 'time'];
}
```

---
## Наследование

### Title
```php

```

---
## Алгоритм сбора мусора
* Объекты ***без ссылок, немедленно*** вызывают свой деструктор и удаляются из памяти
* Любой объект имеет скрытое поле, хранящее ***счетчик ссылок***
* Удаление объекта или массива:
  1. Удалить все ссылки (содержит сам объект)
  2. Вызвать деструктор
  3. Освободить занимаемую память

### Циклические(кольцевые) ссылки
* ***Проблема*** - Когда родительский объект хранит ссылки на всех своих потомков, а потомки на своего родителя
  * После уничтожения ссылок на такие объекты, сборщик мусора их не удаляет
  * Аналогия: "ключи от машины в квартире, ключи от квартиры в сейфе, ключи от сейфа - в машине"
```php
class Father {}
```
* ***Проблема*** - Когда объект ссылается сам на себя
  * После уничтожения ссылки продолжает существовать в памяти
```php
class Station { public $exit; }
$object = new Station;
$object->exit = $object;  // ссылается сам на себя
unset($object);           // объект не будет удален
```
* ***ИТОГ*** - Сборщик мусорва и деструктор ***"не срабатывают"***, когда в программе имеются ***кольцевые ссылки***
