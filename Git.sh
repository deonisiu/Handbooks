ОБЩАЯ ИНФОРМАЦИЯ ПРО GIT {
Подход Git’а к хранению данных больше похож на набор снимков миниатюрной файловой системы. 
Каждый раз, когда вы делаете коммит, то есть сохраняете состояние своего проекта в Git’е, система запоминает, как выглядит каждый файл в этот момент, и сохраняет ссылку на этот снимок. 
Для увеличения эффективности, если файлы не были изменены, Git не запоминает эти файлы вновь, а только создаёт ссылку на предыдущую версию идентичного файла, который уже сохранён. Git представляет свои данные как, скажем, поток снимков. https://git-scm.com/book/en/v2/images/snapshots.png
Git имеет три основных состояния, в которых могут находиться ваши файлы: зафиксированном (committed), изменённом (modified) и подготовленном (staged). 

"Зафиксированный"(committed) значит, что файл уже сохранён в вашей локальной базе. 
К "изменённым"(modified) относятся файлы, которые поменялись, но ещё не были зафиксированы. 
"Подготовленные"(staged) файлы — это изменённые файлы, отмеченные для включения в следующий коммит.

Мы подошли к трём основным секциям проекта Git: 
1) Git-директория (Git directory)
2) рабочая директория (working directory) 
3) область подготовленных файлов (staging area).
https://git-scm.com/book/en/v2/images/areas.png

1) Git-директория — это то место, где Git хранит метаданные и базу объектов вашего проекта. Это самая важная часть Git, и это та часть, которая копируется при клонировании репозитория с другого компьютера.

2) Рабочая директория является снимком версии проекта. Файлы распаковываются из сжатой базы данных в Git-директории и располагаются на диске, для того чтобы их можно было изменять и использовать.

3) Область подготовленных файлов — это файл, располагающийся в вашей Git-директории, в нём содержится информация о том, какие изменения попадут в следующий коммит. Эту область ещё называют “индекс”, однако называть её stage-область также общепринято.

Базовый подход в работе с Git выглядит так:
  1 Вы изменяете файлы в вашей рабочей директории.
  2 Вы добавляете файлы в индекс, добавляя тем самым их снимки в область подготовленных файлов.
  3 Когда вы делаете коммит, используются файлы из индекса как есть, и этот снимок сохраняется в вашу Git директорию.

В состав Git’а входит утилита git config, которая позволяет просматривать и настраивать параметры, контролирующие все аспекты работы Git’а, а также его внешний вид. Эти параметры могут быть сохранены в трёх местах:
  1) Файл /etc/gitconfig содержит значения, общие для всех пользователей системы и для всех их репозиториев. Если при запуске git config указать параметр --system, то параметры будут читаться и сохраняться именно в этот файл.
  2) Файл ~/.gitconfig или ~/.config/git/config хранит настройки конкретного пользователя. Этот файл используется при указании параметра --global.
  3) Файл config в каталоге Git’а (т.е. .git/config) в том репозитории, который вы используете в данный момент, хранит настройки конкретного репозитория.
  Настройки на каждом следующем уровне подменяют настройки из предыдущих уровней, то есть значения в .git/config перекрывают соответствующие значения в /etc/gitconfig.
  
}

НАСТРОЙКИ {
//? Смена текстового редактора
$ git config --global core.editor <redactor_name>

//? Имя пользователя
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com

//? Проверка настроек
$ git config --list

//? Проверка значения конкретного ключа
$ git config <parametr>

//? Есть два способа открыть страницу руководства по любой команде Git:
$ git help <глагол>
$ git <глагол> --help
Например: $ git help config

}

БАЗОВЫЕ КОМАНДЫ (создать репозиторий, добавить файл, удалить, коммит) {
//? Создание репозитория в существующей директории
$ git init
На этом этапе ваш проект ещё не находится под версионным контролем.

//? Отслеживание(добавить под версионный контроль) новый файл
//? Добавить этот контент в следующий коммит
$ git add <filename>
Пример: $ git add README 
git add. Это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для индексации изменений, а также для других целей, например для указания файлов с исправленным конфликтом слияния. Вам может быть понятнее, если вы будете думать об этом как ``добавить этот контент в следующий коммит``.

//? Коммит изменений + комментарий в редакторе $EDITOR
$ git commit

//? Коммит изменений + комментарий в строке команды
$ git commit -m
Пример: $ git commit -m "comment here"

//? Игнорирование индексации
$git commit -a -m "comment"
В таком случае не нужно использовать команду $ git add

//? Удаление файла если он ещё не проиндексирован (файл удаляется полностью)
$ git rm <filename>

//? Удаление файла даже если он уже проиндексирован (файл удаляется полностью)
$ git rm -f <filename>

//? Перевод файла из индекса в untracked (файл не удаляется)
$ git rm --cached <filename>
В команду git rm можно передавать файлы, каталоги или glob-шаблоны.
Например:
$ git rm log/\*.log (* экранируется черех \ , команда удаляет все файлы расширения .log в папке log/
$ git rm \*~ (удаляет все файлы, чьи имена заканчиваются на ~)

//? Переименование файла
$ git mv <file_from> <file_to>
Пример: $ git mv README.md README.txt
Тоже самое если бы мы написали три команды:
$ mv README.md README.txt
$ git rm README.md
$ git add README.txt

}

СТАТУС ФАЙЛОВ РЕПОЗИТОРИЯ {

//? Определение состояния файлов
$ git status

//? Сокращенный вывод статуса
$ git status -s
Пример:
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
ГДЕ: 'M' - modified+, ' M' - modified-, 'A' - add, '??' - untracked, 'AM' - add and modified-, 'MM' - modified+ and modified-
modified+ - модифицирован и проиндексирован(готов к коммиту)
modified- - модифицирован и не проиндексирован(не готов к коммиту)

//? Просмотр неиндексированных изменений (до команды $ git add)
$ git diff

//? Просмотр индексированных изменений (после команды $ git add)
$ git diff --cached

//? Сравнение индексированных изменений с последним коммитом
$ git diff --staged

}

ИГНОРИРОВАНИЕ ФАЙЛОВ {
Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых. 
К таким файлам обычно относятся автоматически генерируемые файлы (различные логи, результаты сборки программ и т.п.). 
В таком случае, вы можете создать файл .gitignore. с перечислением шаблонов соответствующих таким файлам. Вот пример файла .gitignore:

$ touch .gitignore (сначала создаем игнор файл)
Записываем в него правила игнорирования например: '*.gitignore'
$ cat .gitignore (показывает содержимое файла)
*.gitignore

Первая строка предписывает Git игнорировать любые файлы заканчивающиеся на ``.o`` или ``.a`` - объектные и архивные файлы, которые могут появиться во время сборки кода. Вторая строка предписывает игнорировать все файлы заканчивающиеся на тильду (~), которая используется во многих текстовых редакторах, например Emacs, для обозначения временных файлов. Вы можете также включить каталоги log, tmp или pid; автоматически создаваемую документацию; и т.д. и т.п. Хорошая практика заключается в настройке файла .gitignore до того, как начать серьёзно работать, это защитит вас от случайного добавления в репозиторий файлов, которых вы там видеть не хотите.

К шаблонам в файле .gitignore применяются следующие правила:
1 Пустые строки, а также строки, начинающиеся с #, игнорируются.
2 Можно использовать стандартные glob шаблоны.
3 Можно начать шаблон символом слэша (/) чтобы избежать рекурсии.
4 Можно заканчивать шаблон символом слэша (/) для указания каталога.
5 Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого символа.

Glob-шаблоны представляют собой упрощённые регулярные выражения, используемые командными интерпретаторами. Символ (*) соответствует 0 или более символам; последовательность [abc] — любому символу из указанных в скобках (в данном примере a, b или c); знак вопроса (?) соответствует одному символу; и квадратные скобки, в которые заключены символы, разделённые дефисом ([0-9]), соответствуют любому символу из интервала (в данном случае от 0 до 9). Вы также можете использовать две звёздочки, чтобы указать на вложенные директории: a/**/z соответствует a/z, a/b/z, a/b/c/z, и так далее.

Вот ещё один пример файла .gitignore:
# no .a files
*.a
# but do track lib.a, even though youre ignoring .a files above
!lib.a
# only ignore the root TODO file, not subdir/TODO
/TODO
# ignore all files in the build/ directory
build/
# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt
# ignore all .txt files in the doc/ directory
doc/**/*.txt

}

ПРОСМОТР ИСТОРИИ КОММИТОВ {
//? Просмотр истории коммитов (сверху последние)
$ git log

//? Подробный просмотр коммита
$ git show (последний коммит в ветке)
$ git show <hash(7 numb)> (по первым 7 цифрам из хеш суммы) 

//? Просмотр истории коммитов  + разница внесенная в каждый коммит
$ git log -p //* В MERGE НЕ ПОКАЗЫВАЕТ ИЗМЕНЕНИЯ *//
$ git log -p -[number] (где number количество отображаемых коммитов)

//? Просмотр истории коммитов + краткая разница + количество измененных строк
$ git log --stat

//? Просмотр истории коммитов в одну строку
$ git log --pretty=oneline
$ git log --oneline (сокращенная форма, хеш сумма в 7 символов)

//? Просмотр истории коммитов в определенном формате
$ git log --pretty=format:"view format"
Пример: $ git log --pretty=format:"%h - %an, %ar : %s"
$ 4c0ded5 - Denis Savich, 8 minutes ago : Commit 5: A-style.css
$ e4f22c1 - Denis Savich, 7 hours ago : Commit 4: A - delete.txt
Опции для FORMAT: $ git log --pretty=format {
	%H - Хеш коммита
	%h - Сокращенный хеш коммита
	%T - Хеш дерева
	%t - Сокращенный хеш дерева
	%P - Хеш родителей
	%p - Сокращенный хеш родителей
	%an - Имя автора
	%ae - Электронная почта автора
	%ad - Дата автора (формат даты можно задать опцией --date=option)
	%ar - Относительная дата автора
	%cn - Имя коммитера
	%ce - Электронная почта коммитера
	%cd - Дата коммитера
	%cr - Относительная дата коммитера
	%s - Содержание
Автор – это человек, изначально сделавший работу, а коммитер – это человек, который последним применил эту работу. 
}

//? Посмотр истории коммитов в виде графа
$ git log --pretty=format:"%h %s" --graph
$ git log --pretty=oneline --graph
Показывает текущую ветку и историю слияний

Основные опции для команды $ git log {
	-p - Показывает патч для каждого коммита.
	--stat - Показывает статистику измененных файлов для каждого коммита.
	--shortstat - Отображает только строку с количеством изменений/вставок/удалений для команды --stat.
	--name-only - Показывает список измененных файлов после информации о коммите.
	--name-status - Показывает список файлов, которые добавлены/изменены/удалены.
	--abbrev-commit - Показывает только несколько символов SHA-1 чек-суммы вместо всех 40.
	--relative-date - Отображает дату в относительном формате (например, "2 weeks ago") вместо стандартного формата даты.
	--graph - Отображает ASCII граф с ветвлениями и историей слияний.
	--pretty - Показывает коммиты в альтернативном формате. Возможные варианты опций: oneline, short, full, fuller и format (с помощью последней опции вы можете указать свой формат).
}

//? Просмотр истории с ограничением вывода
$ git log -4 (последние 4 записи)
$ git log --since=2.weeks (за последние 2 недели)
$ git log --since="2008-01-15"
$ git log --since="2 years 1 day 3 minutes ago"

//? Фильтрование истории коммитов
$ git log --author="Savich" (фильтр по имени автора)
$ git log --grep="Commit 3" (фильтр по ключевым словам в сообщении коммита)
$ git log -S"text key" (фильтр по ключевым словам внутри файла)

Опции для ограничения вывода команды $ git log {
	-(n) - Показывает только последние n коммитов.
	--since="text", --after="text" - Показывает только те коммиты, которые были сделаны после указанной даты.
	--until="text", --before="text" - Показывает только те коммиты, которые были сделаны до указанной даты.
	--author="text" - Показывает только те коммиты, в которых запись author совпадает с указанной строкой.
	--committer="text" - Показывает только те коммиты, в которых запись committer совпадает с указанной строкой.
	--grep="text" - Показывает только коммиты, сообщение которых содержит указанную строку.
	-S"text" - Показывает только коммиты, в которых изменение в коде повлекло за собой добавление или удаление указанной строки.
}

}

ОПЕРАЦИИ ОТМЕНЫ {
//? Переделать последний коммит
$ git commit --amend [-m "text"]
Пример:
$ git commit -m "text"
$ git add file.txt
$ git commit --ammend -m "new text" (добавление file.txt в последний коммит + новый комментарий)

//? Отмена подготовки файла (перенос из индекса в рабочую область)
$ git reset HEAD <file>
//* Добавил алиас "reset HEAD --" = "unstage" *//

//? Отмена изменений файла и откат к последней его версии в Git
$ git checkout -- <file> (ОПАСНАЯ КОМАНДА УДАЛЯЕТ ВСЕ ИЗМЕНЕНИЯ ФАЙЛА)
Всё что удаляется до КОММИТА восстановить уже невозможно!
//* Добавил алиас "checkout --" = "back" *//
}

РАБОТА С УДАЛЕННЫМИ РЕПОЗИТОРИЯМИ {
//? Клонирование существующего репозитория
$ git clone <path>
Пример: $ git clone https://github.com/libgit2/libgit2 (directoryname)
Автоматический добавляет удаленный репозиторий под именем "origin"

//? Просмотр списка настроенных удаленных репозиториев
$ git remote
Покажет: origin (если это клонированый репозиторий)

//? Просмотр адресов для чтения и для записи привязанные к репозиторию
$ git remote -v
Покажет:
origin  https://github.com/deonisiu/Front-end_websites.git (fetch)
origin  https://github.com/deonisiu/Front-end_websites.git (push)
Если у вас больше одного удаленного репозитория команда выведет их все например:
$ git remote -v
bakkdoor  https://github.com/bakkdoor/grit (fetch)
bakkdoor  https://github.com/bakkdoor/grit (push)
cho45     https://github.com/cho45/grit (fetch)
cho45     https://github.com/cho45/grit (push)
defunkt   https://github.com/defunkt/grit (fetch)
defunkt   https://github.com/defunkt/grit (push)

//? Добавление удаленных репозиториев
$ git remote add [shortname] [url]
Пример: 
$ git remote
origin
$ git remote add pb https://github.com/paulboone/ticgit
$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
pb	https://github.com/paulboone/ticgit (fetch)
pb	https://github.com/paulboone/ticgit (push)
Теперь вместо указания полного пути вы можете использовать pb. Например, если вы хотите получить изменения, которые есть у Пола, но нету у вас, вы можете выполнить команду $ git fetch pb

//? Получение изменений из удаленного репозитория 
$ git fetch [remote-name] (появляется новая ветка проекта [remote-name])
Пример:
$ git remote add den https://github.com/deonisiu/for-tests2.git
$ git fetch den (добавляет ссылки на все ветки из проекта den)
В ветке origin при этом ничего не меняется
Важно отметить, что команда git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

//? Автоматическое получение и слияние изменений из удаленной ветки
$ git pull (извлекает (fetch) данные с сервера, с которого изначально склонирован репозиторий и автоматически пытается слить (merge) их с текущим кодом)
Если ветка настроенна на отслеживание удаленной ветки(тема о ветвлении в Git)

//? Отправка изменений в удаленный репозиторий 
$ git push [remote-name] [branch-name]
Пример: $ git push origin master (срабатывает если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Если команду push кто то уже выполнял то ваш push точно будет отклонен. Вам придется сначала вытянуть (pull) их изменения и объеденить с вашими и только потом будет позволено выполнить push.

Более подробно в теме о ветвлении в Git.

//? Просмотр удаленного репозитория (больше информации)
$ git remote show [remote-name]
Пример: $ git remote show origin

//? Переименование удаленного репозитория
$ git remote rename [remote-name] [new-name]
Пример: 
$ git remote 
origin
den
$ git remote rename den denis
$ git remote
origin
denis

//? Удаление удаленного репозитория
$ git remote rm [remote-name]
Пример: $ git remote rm den
$ git remote
origin 

}

РАБОТА С МЕТКАМИ {
Git использует два основных типа меток: легковесные и аннотированные.
1) Легковесная метка — это что-то весьма похожее на ветку, которая не меняется — это просто указатель на определённый коммит.
2) Аннотированные метки хранятся в базе данных Git’а как полноценные объекты. Они имеют контрольную сумму, содержат имя поставившего метку, e-mail и дату, имеют комментарий и могут быть подписаны и проверены с помощью GNU Privacy Guard (GPG).

//? Просмотр меток (перечисляет метки в алфавитном порядке)
$ git tag 
$ git tag -l 'text' (поиск меток по шаблону в 'text')
Пример: $ git tag -l 'v1.8.5*' (все теги начинающиеся на 'v1.8.5')

//? Создание легковесной метки для последнего коммита
$ git tag <ver>
Пример: $ git tag v1.4-lt

//? Создание аннотированной метки  для последнего коммита
$ git tag -a <ver> (комментарий пишется в vim)
$ git tag -a <ver> -m "text" (комментарий пишется в text)
Пример: $ git tag -a v1.4 -m "my version 1.4"
Где -m 'text' сообщение метки, которое будет храниться вместе с меткой.

//? Просмотр коммита по тегу
$ git show <ver> 
Пример: $ git show v1.4-lt (легкий тег покажет коммит с данным тегом)
Пример: $ git show v1.4 (аннотированный тег покажет коммит с данным тегом + инфу по тегу)

//? Удаление тега
$ git tag -d <ver>

//? Создание метки любому коммиту (через контрольную сумму часть первых символов)
$ git tag -a <ver> 9fceb0 (первые 6 символов контрольной суммы коммита)
$ git tag <ver> 9fceb0 (тоже самое только для легкого тега)

По умолчанию команда $ git push не отправляет метки на удаленный сервер.
Необходимо явно отправить метки на общий сервер, после их создания.

//? Отправка метки на удаленный сервер
$ git push [remote-name] [tag-name]
Пример: $ git push origin v1.4

//? Отправка всех меток на удаленный сервер
$ git push [remote-name] --tags
Пример: $ git push origin --tags


}

ПСЕВДОНИМЫ (АЛИАСЫ - aliases) {
//? Создание нового алиаса
$ git config --global alias.<text> <git-command>
Пример:
$ git config --global alias.co checkout ($ git co вместо $ git checkout)
$ git config --global alias.br branch ($ git br вместо $ git branch)
$ git config --global alias.ci commit ($ git ci вместо $ git commit)
$ git config --global alias.st status ($ git st вместо $ git status)
$ git config --global alias.unstage 'reset HEAD' ($ git unstage <file> вместо $ git reset HEAD <file>)


}

ВЕТВЛЕНИЕ В GIT (killer feature) {

ОСНОВНЫЕ КОМАНДЫ {
В Git, HEAD это указатель на локальную ветку, в которой вы находитесь.

//? Посмотреть список всех созданных веток
$ git branch

//? Посмотреть последний коммит на каждой из веток
$ git branch -v

//? Посмотреть список веток которые вы слили в ветку на которой сейчас находитесь
$ git branch --merged 
$ git branch --no-merged (обратная команда)

//? Создание новой ветки
$ git branch <branch-name>
Пример: $ git branch testing
В результате создается новый указатель на тот же самый коммит, в котором вы находитесь.

//? Удаление ветки
$ git branch -d <branch-name> (не удаляется если изменения не слиты)
$ git branch -D <branch-name> (сразу удаляется)

//? Переключение веток
$ git checkout <branch-name> (переключиться на ветку <branch-name>)
$ git checkout -b <branch-name> (создать ветку и сразу переключиться на нее)
Пример: $ git checkout testing
В результате HEAD переместиться на ветку testing
//*Переключение веток меняет файлы в рабочем каталоге!*//
Важно запомнить, что когда вы переключаете ветки в Git, файлы в рабочем каталоге меняются. Если вы переключаетесь на старую ветку, то рабочий каталог будет выглядеть так же, как выглядел на момент последнего коммита в ту ветку.
//* Untracked файлы отображаются во всех ветках *//

//? Просмотр всех веток со всеми коммитами в одну строку в виде графа
$ git log --oneline --graph --all
//* Добавил алиас "log --oneline --graph --all" = "all" *//

//? Слияние веток (слияние указанной ветки в текущую)
$ git merge <branch-name> (слияние <branch-name> ветки с текущей)
Если коммит сливается с тем, до которого можно добраться, двигаясь по истории прямо, Git упрощает слияние, просто перенося указатель метки вперед (так как нет разветвления в работе). Это называется ``fast-forward`` (перемотка). 

//? Разрешение конфликта слияния через графический инструмент
$ git mergetool
Далее вы можете ввести $ git commit, чтобы завершить коммит слияния.
$ git show покажет подробный результат коммита 

}

КОНФЛИКТ СЛИЯНИЯ {
Если вы изменили одну и ту же часть одного и того же файла по-разному в двух объединяемых ветках, Git не сможет их чисто объединить.
Git не создал коммит слияния автоматически. Он остановил процесс до тех пор, пока вы не разрешите конфликт. 
Чтобы в любой момент после появления конфликта увидеть, какие файлы не объединены, вы можете запустить $ git status
Все, где есть неразрешенные конфликты слияния, перечисляется как неслитое. Git добавляет в конфликтующие файлы стандартные пометки разрешения конфликтов, чтобы вы могли вручную открыть их и разрешить конфликты.
}

ВИДЫ ВЕТОК (ТЕОРИЯ) {
//* Долгоживущие ветки *//
Так как в Git применяется простое трехэтапное слияние, ничто не мешает многократно объединять ветки в течении длительного времени. То есть у вас может быть несколько постоянно открытых веток, применяемых для разных этапов цикла разработки. Содержимое некоторых из них будет регулярно сливаться в другие ветки.
Многие разработчики, использующие Git, придерживаются именно такого подхода, оставляя полностью стабильный код только в ветке master. При этом существует и параллельная ветка с именем develop или next, служащая для работы и тестирования стабильности. После достижения стабильного результата ее содержимое сливается в ветку master.
Схема: C1-C7 коммиты, Master-Develop-Topic ветки
C1 - - - - - - - - - - - - - - - - - - - -MASTER>>
   \
     C2 < - C3 < - C4 < - C5 - - - - - - -DEVELOP>>
						     \
							   C6 < - C7 -TOPIC>>
	 
//* Тематические ветки *//
Тематической (topic branch) называется временная ветка, создаваемая и используемая для работы над конкретной функциональной возможностью или решения сопутствующих задач.
Пример тематических веток hotfix, error для каждой из них было выполнено несколько коммитов, после чего сразу же после слияния с основной веткой они были удалены.
Работа разделена по уровням, и все изменения в конкретной ветке относятся к определенной теме, а значит, во время просмотра кода проще понять, что и где было сделано.
}

}


















